
func testCheck(coreDataStack: CoreDataStack, needUpdate: Bool){

let fetchRequest = NSFetchRequest(entityName: "Time")
var error: NSError?

let results = coreDataStack.context.countForFetchRequest(fetchRequest, error: &error)

println(results)
if results == 0 || needUpdate{

var fetchError: NSError? = nil

let results = coreDataStack.context.executeFetchRequest(fetchRequest, error: &fetchError)

for object in results!{
let cube = object as Time
coreDataStack.context.deleteObject(cube)
}

coreDataStack.saveContext()
//self.startXMLParser(coreDataStack)
}
}





//var currentTime: Time!

func checkTime(coreDataStack: CoreDataStack){

let fetchRequest = NSFetchRequest(entityName: "Time")
var error: NSError? = nil

let results = coreDataStack.context.countForFetchRequest(fetchRequest, error: &error)

if results > 0 {
let timeEntity = NSEntityDescription.entityForName("Time", inManagedObjectContext: coreDataStack.context)
let time = Time(entity: timeEntity!, insertIntoManagedObjectContext: coreDataStack.context)

let timeFetch = NSFetchRequest(entityName: "Time")

var error: NSError?

let result = coreDataStack.context.executeFetchRequest(timeFetch, error: &error) as [Time]?

if let times = result{
currentTime = Time(entity: timeEntity!, insertIntoManagedObjectContext: coreDataStack.context)

var dateFormatter = NSDateFormatter()
dateFormatter.dateFormat = "yyyy-MM-dd"
let dateNow: String! = dateFormatter.stringFromDate(NSDate())

if !(times[0].lastUpdate == dateNow) {
currentTime.lastUpdate = dateNow
coreDataStack.saveContext()
}


}
}
}
}

func checkAndupdateTimeIfNeeded(coreDataStack: CoreDataStack){

var dateFormatter = NSDateFormatter()
dateFormatter.dateFormat = "yyyy-MM-dd" //"MM-dd-yyyy"

let dateNow: String! = dateFormatter.stringFromDate(NSDate())

let fetchRequest = NSFetchRequest(entityName: "Time")
var error: NSError?

let results = coreDataStack.context.countForFetchRequest(fetchRequest, error: &error)

if results > 0 {

let timeEntity = NSEntityDescription.entityForName("Time", inManagedObjectContext: coreDataStack.context)
let time1 = Time(entity: timeEntity!, insertIntoManagedObjectContext: coreDataStack.context)

//asyncFetchTimeFromContext(coreDataStack)

let dateOld: String! = time1.lastUpdate
println("DateOLD: \(dateOld)")
let isDateEqual = (dateNow == dateOld)
if !isDateEqual {
var fetchError: NSError? = nil

let results = coreDataStack.context.executeFetchRequest(fetchRequest, error: &fetchError)

for object in results!{
let time = object as Time
coreDataStack.context.deleteObject(time)
}

println("DateNOW: \(dateNow)")
//var dateValue: NSDate! = dateFormatter.dateFromString(dateNow)!
//time.lastUpdate = ""//dateNow//dateValue!
coreDataStack.saveContext()
}
} else {
println("DateNoW: \(dateNow)")

let timeEntity = NSEntityDescription.entityForName("Time", inManagedObjectContext: coreDataStack.context)
let time1 = Time(entity: timeEntity!, insertIntoManagedObjectContext: coreDataStack.context)

time1.lastUpdate = dateNow
coreDataStack.saveContext()
}
}












/*
func asyncFetchTimeFromContext(coreDataStack: CoreDataStack){
var fetchRequest: NSFetchRequest!
var asyncFetchRequest: NSAsynchronousFetchRequest!

fetchRequest = NSFetchRequest(entityName: "Time")

asyncFetchRequest = NSAsynchronousFetchRequest(fetchRequest: fetchRequest){
[unowned self] (result: NSAsynchronousFetchResult!) -> Void in

self.time = result.finalResult as [Time]
}

var error: NSError?
let results = coreDataStack.context.executeRequest(asyncFetchRequest, error: &error)

if let persistentStoreResults = results{

} else {
println("Could not fetch \(error), \(error!.userInfo)")
}

}*/






/*
func loadTime(){
let appDelegate = UIApplication.sharedApplication().delegate as AppDelegate
let managedContext = appDelegate.managedObjectContext!
let fetchRequest = NSFetchRequest(entityName: "TimeEntity")

var error: NSError?
let fetchedResults = managedContext.executeFetchRequest(fetchRequest, error: &error) as [NSManagedObject]?

if let results = fetchedResults {
println("loadTime: Results \(results.count)")
if results.count == 0 {
// First time
println("First time")
self.startXMLParser()
saveTime()

} else {

// println("nÃ¥nting: \(results[0])")

checkTime(results[0].valueForKey("time")! as NSDate)
/*
for result in results as NSArray {
println(result.valueForKey("time")! as NSDate)
checkTime(result.valueForKey("time")! as NSDate)
}*/
}
} else {
println("Could not fetch \(error), \(error!.userInfo)")
}
}
*/

/*
func checkTime(time1: NSDate){
let time2: NSDate = NSDate(timeIntervalSinceNow: NSTimeInterval(0))
let interval = time2.timeIntervalSinceDate(time1)
var newtime = (interval / 60) / 60

if newtime > 24 {
self.startXMLParser()
} else {
self.load()
}

println(newtime)

}
*/

/*

func saveTime(){
let appDelegate = UIApplication.sharedApplication().delegate as AppDelegate

let managedContext = appDelegate.managedObjectContext!
//managedContext.deletedObjects // Delete all objects in the manageContext.
/*let fetchRequest = NSFetchRequest(entityName:"TimeEntity")
fetchRequest.predicate = NSPredicate(
format: "time")
let count = managedContext.countForFetchRequest(fetchRequest, error: nil);
*/

let fetchRequest = NSFetchRequest(entityName: "RateEntity")

var error: NSError?

let fetchedResults = managedContext.executeFetchRequest(fetchRequest, error: &error) as [NSManagedObject]?






let entity = NSEntityDescription.entityForName("TimeEntity", inManagedObjectContext: managedContext)
let time = NSManagedObject(entity: entity!, insertIntoManagedObjectContext: managedContext)

let date: NSDate = NSDate(timeIntervalSinceNow: NSTimeInterval(0))

time.setValue(date, forKey: "time")

if managedContext.save(&error){
println("saveTime Saved! \(date)")
latestParseTime = "\(date)"
} else {
println("Could not save \(error), \(error?.userInfo)")
}
}

func load() -> Int{
let appDelegate = UIApplication.sharedApplication().delegate as AppDelegate
let managedContext = appDelegate.managedObjectContext!

let fetchRequest = NSFetchRequest(entityName: "RateEntity")

var error: NSError?
let fetchedResults = managedContext.executeFetchRequest(fetchRequest, error: &error) as [NSManagedObject]?

if let results = fetchedResults {
println("load: Results \(results.count)")
for result in results as NSArray {
currencyDict[result.valueForKey("currency")! as String] = result.valueForKey("rate")! as? Double
}

return results.count
} else {
println("Could not fetch \(error), \(error!.userInfo)")
return 0
}
}

func saveData(){
for var i = 0; i < currencyDict.count; ++i{
self.save(currencyArray[i], rate: currencyDict[currencyArray[i]]!)
}
println(currencyDict.count)
}



func save(currency: String, rate: Double){
let appDelegate = UIApplication.sharedApplication().delegate as AppDelegate

let managedContext = appDelegate.managedObjectContext!
//managedContext.deletedObjects // Delete all objects in the manageContext.
//println(managedContext.deletedObjects)

let entity = NSEntityDescription.entityForName("RateEntity", inManagedObjectContext: managedContext)

let currencyAndRate = NSManagedObject(entity: entity!, insertIntoManagedObjectContext: managedContext)

currencyAndRate.setValue(rate, forKey: "rate")
currencyAndRate.setValue(currency, forKey: "currency")

var error: NSError?
if managedContext.save(&error){
//println("save: Saved!")
} else {
println("Could not save \(error), \(error?.userInfo)")
}
}

func deleteAllObjects(entityName: String){

let appDelegate = UIApplication.sharedApplication().delegate as AppDelegate
let managedContext = appDelegate.managedObjectContext!

let fetchRequest = NSFetchRequest(entityName: entityName)

var error: NSError?
let fetchedResults = managedContext.executeFetchRequest(fetchRequest, error: &error) as [NSManagedObject]?
var managedObject: NSManagedObject!
}
*/

/*
- (void) deleteAllObjects: (NSString *) entityDescription  {
NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
NSEntityDescription *entity = [NSEntityDescription entityForName:entityDescription inManagedObjectContext:_managedObjectContext];
[fetchRequest setEntity:entity];

NSError *error;
NSArray *items = [_managedObjectContext executeFetchRequest:fetchRequest error:&error];
[fetchRequest release];


for (NSManagedObject *managedObject in items) {
[_managedObjectContext deleteObject:managedObject];
DLog(@"%@ object deleted",entityDescription);
}
if (![_managedObjectContext save:&error]) {
DLog(@"Error deleting %@ - error:%@",entityDescription,error);
}

}
*/